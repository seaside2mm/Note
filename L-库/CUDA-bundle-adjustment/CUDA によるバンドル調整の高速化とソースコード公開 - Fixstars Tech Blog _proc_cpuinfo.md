---
url: https://proc-cpuinfo.fixstars.com/2020/10/cuda-bundle-adjustment/
title: CUDA によるバンドル調整の高速化とソースコード公開 - Fixstars Tech Blog /proc/cpuinfo
date: 2023-01-23 09:13:26
tag: 
summary: はじめに こんにちは、エンジニアの高木です。
---
## はじめに

## 背景

バンドル調整 (Bundle Adjustment) とは、画像からの 3 次元復元において 3 次元点群とカメラ姿勢を改善する手法で、点群を画像上に再投影したときに、観測データに最も当てはまるような 3 次元点群とカメラ姿勢を推定する問題です。

![](https://proc-cpuinfo.fixstars.com/wp-content/uploads/2020/10/ba-3.png)

**バンドル調整のイメージ**  
3 次元点 (★) を画像上に再投影したときの、観測データとの誤差 (赤線の長さ) が最小となるを推定する

Visual SLAM の代表的手法である ORB-SLAM2 では、ループ閉じ込みが行われたタイミングで、これまでに復元した全ての 3 次元点群と、全てのキーフレームの姿勢を改善するためにバンドル調整が用いられます。このバンドル調整は、論文中では Motion Only BA や Local BA と区別し、Full BA と呼ばれます。

Full BA は扱う問題の規模が大きく、大きな処理時間がかかることがあります。例えば、KITTI データセットの sequences/00 という比較的長いシーケンスでは、最後のループ閉じ込み後に行う Full BA で、**約 12 秒**の処理時間がかかることが分かりました。

この結果に対する「CUDA で実装したらどの程度速くなるのか」という興味・疑問が、このプロジェクトを始めたきっかけになります。うまく高速化できれば、最適化開始から点群と姿勢を更新するまでの遅延を短縮したり、CPU のリソースを軽減するといったメリットがあります。

## バンドル調整のアルゴリズム

#### 問題の定式化

番目のカメラの姿勢を、番目の 3 次元点の座標をとし、これらを並べたものをとします。がバンドル調整における未知数となります。の次元は、カメラ数を、3 次元点数をとしてです。

番目のカメラで撮影した画像中の、番目の 3 次元点に対応する特徴点を観測と呼びで表します。また、番目のカメラに番目の 3 次元点を再投影した点と、との誤差を再投影誤差と呼び、で表します。

バンドル調整は再投影誤差の二乗和を目的関数とし、を最小化するを求める問題として定式化されます。

は重み行列で、観測の不確かさ (分散) から計算されます。

#### 非線形最小二乗法

バンドル調整の問題は非線形最小二乗問題に分類され、解法として Gauss-Newton 法や Levenberg-Marquardt 法が良く利用されます。Gauss-Newton 法のアルゴリズムは以下の通りです。

*   解を初期化
    
*   終了条件を満たすまで以下を繰り返し
    1.  現在のにおける再投影誤差、ヤコビアンを求める
    2.  を計算
    3.  線形方程式を解く
    4.  解の更新：

線形方程式においてとしたものが Levenberg-Marquardt 法 (LM 法) です。は更新量の大きさを調節するパラメータで、dumping factor と呼ばれます。

#### 係数行列の構造

線形方程式

において、

のサイズは

と、カメラ数と点群数に応じて大きくなります。冒頭で紹介した 12 秒かかるケースでは、

が約 40 万と大規模になり、直接解くことが厳しくなってきます。

そこでバンドル調整では

の構造を利用して、方程式をより小規模な問題に分割して解きます。

は以下の区分行列の形で表現することができます。

はそれぞれブロック疎行列 (特定のブロック以外は

) という特徴があります。特に、

は対角ブロック以外が

の、ブロック対角行列です。

さて、

という形の区分行列に対して、**シューア補行列 (Schur complement)** という行列が定義され、

の

に対するシューア補行列

は以下のように定義されます。

記載は省略しますが、シューア補行列を用いての逆行列を表現することができ、を整理すると、に関する 2 つの方程式を得ます。

上記より、まず

を解いて

が求められ、次に

を用いて

を解いて

が求められます。式中の

は、

がブロック対角行列であるため、計算が容易という性質があります。

を解く際も

を直接利用できます。

実質的に解く必要がある線形方程式は

のみになり、問題の規模も

に縮小されます。

は正定値対称行列という性質があり、コレスキー分解を用いて

と分解することで線形方程式を解くことができます。

## CUDA 化の内容

#### リファレンス実装

CUDA 化にあたり、ORB-SLAM2 で使用されているグラフ最適化ライブラリ [g2o](https://github.com/RainerKuemmerle/g2o) をリファレンス実装としました。g2o の内、バンドル調整で行われる処理の抽出、各処理の CUDA 化の検討・実装を行いました。

結論から言うと、ほとんどの処理は並列化と相性が良く、CUDA 化によって高速化効果が得られました。もともとの実装規模が大きく、全ての処理を CUDA 化するのには手間がかかりましたが…

#### 再投影誤差と係数行列の計算

現在の解における再投影誤差を計算し、続いてヤコビアン、係数行列を計算します。これらの計算量は与えられたの組み合わせ、すなわち観測の数に比例します。個々の要素は累積計算を除いて独立に計算できるため、並列化による高速化効果が期待できます。

#### シューア補行列の計算

を求めるにあたり、まず

と

を計算します。ここではブロック疎行列の演算がメインになります。計算に現れる各行列の非ゼロブロックは特殊なパターンをもち、かつ反復中に変化しないため、これに特化した CUDA 実装を行っています。

は

がブロック対角行列のため、計算が容易です。各ブロックで

の逆行列を計算します。次に

を計算します。疎行列同士の積ですが、片方 (

) がブロック対角行列のため、実装がシンプルで済みます。

続いて

を用いて

と

を計算します。前者は疎行列ベクトル積で、比較的実装が容易です。後者は疎行列同士の積で、リファレンス実装を素直に CUDA 化するとスレッド毎に処理負荷がばらつき、難しい個所でした。ここでは、行列積で発生する**ブロック同士の乗算を単位として**並列化し、スレッド数を稼ぎつつ処理負荷を均等化する工夫をしました。

#### 線形方程式の求解

線形方程式

を解きます。前述の通り、ここでは (疎行列の) コレスキー分解を利用します。g2o では、CSParse や CHOLMOD、Eigen 等、ライブラリを選択できるようになっています。本プロジェクトでは CUDA Toolkit 付属の [cuSPARSE](https://docs.nvidia.com/cuda/cusparse/index.html) と [cuSOLVER](https://docs.nvidia.com/cuda/cusolver/index.html) を利用しました。cuSPARSE や cuSOLVER はこれまで注目していませんでしたが、バンドル調整に利用できるのは嬉しいですね。

が求まったら、

を計算します。疎行列ベクトル積がメインの処理です。

#### 解の更新

最後に、を用いて解を更新します。これも各カメラ姿勢と各 3 次元点毎に並列化できます。

## 高速化結果

ORB-SLAM2 と KITTI データセットで取得したカメラ姿勢と 3 次元点群を入力として、処理時間をリファレンス実装の g2o と比較しました。計測プログラムと入力データは公開したソースコードに同封しているため、再現可能です。

高速化結果は以下の通りです。CPU で約 12 秒程度の処理を GPU で約 1.2 秒まで短縮できました。

#### 計測環境

<table><tbody><tr><td>Key</td><td>Value</td></tr><tr><td>CPU / implementation</td><td>Core-i7 6700K(4.00 GHz) / g2o</td></tr><tr><td>GPU / implementation</td><td>GeForce GTX 1080 / cuda-bundle-adjustment</td></tr><tr><td>LM 法の反復回数</td><td>10</td></tr></tbody></table>

#### 処理時間

<table><tbody><tr><td>入力ファイル</td><td data-align="right">カメラ数</td><td data-align="right">3 次元点数</td><td data-align="right">観測数</td><td data-align="right">CPU 処理時間 [sec]</td><td data-align="right">GPU 処理時間 [sec]</td></tr><tr><td>ba_kitti_07.json</td><td data-align="right">248</td><td data-align="right">26127</td><td data-align="right">26127</td><td data-align="right">1.8</td><td data-align="right"><span>0.23</span></td></tr><tr><td>ba_kitti_00.json</td><td data-align="right">1332</td><td data-align="right">133383</td><td data-align="right">561116</td><td data-align="right">11.9</td><td data-align="right"><span>1.23</span></td></tr></tbody></table>

#### 処理時間内訳

GPU で 1.2[sec] のケースにおける処理時間内訳は以下の通りで、処理時間のほとんどはコレスキー分解でした。さらなる高速化を目指す場合は、現状 cuSOLVER に頼っているコレスキー分解を何とかする必要がありそうです。

<table><tbody><tr><td>処理</td><td data-align="right">処理時間 [milli sec]</td></tr><tr><td>初期化</td><td data-align="right">67.9</td></tr><tr><td>前処理 (疎行列の構築、データ転送等)</td><td data-align="right">69.1</td></tr><tr><td>再投影誤差の計算</td><td data-align="right">11.0</td></tr><tr><td>係数行列の計算</td><td data-align="right">50.4</td></tr><tr><td>シューア補行列の計算</td><td data-align="right">106.2</td></tr><tr><td>線形方程式の求解 (コレスキー分解)</td><td data-align="right">908.3</td></tr><tr><td>解の更新</td><td data-align="right">1.2</td></tr></tbody></table>

## ソースコードの公開

## おわりに

CUDA によるバンドル調整の高速化についてご紹介させていただきました。全ての処理を CUDA 化し、納得できる処理時間にするまでには結構な試行錯誤を重ねましたが、こうして一定の高速化効果が得られ、ソースコード公開まで至ることができ嬉しく思います。

最後に、g2o の調査や高速化にご協力いただいた、昨年アルバイトの風見亮佑さんの多大な貢献に感謝いたします。