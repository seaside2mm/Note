
# BaseEdge

- 残差

- 雅可比

  

<p align="center">

  <img src=" https://raw.githubusercontent.com/seaside2mm/github-photos/master/images/20221007162033.png"  width="35%"/>

</p>

  

[BaseEdge类](https://github.com/RainerKuemmerle/g2o/blob/master/g2o/core/base_edge.h)继承了 OptimizableGraph 中的 Edge 类。后面的三种边：`BaseUnaryEdge, BaseBinaryEdge和BaseMultiEdge` 都是继承的 BaseEdge 类。

  

BaseEdge 类主要包含三个成员变量：观测 `_measurement`，信息矩阵 `_information` 和误差 `_error`。其主要实现了关于这三个成员变量的 set, get 函数，还有一个计算加权最小二乘误差的 `chi2` 函数。其他的如 `setVertex, setMeasurement` 等函数已经在父类中实现。

  

另一个比较重要的函数就是 `robustInformation` 函数。这是用来计算鲁棒核函数所对应的信息矩阵的。在这里为了保证信息矩阵的正定性，不使用如下公式：

<p align="center">

  <img src=" https://raw.githubusercontent.com/seaside2mm/github-photos/master/images/20221019164053.png"  width="20%"/>

</p>

  

类似 `ceres-solver`，直接丢弃了二阶项，只计算$\rho^\prime* \Omega $，

  
  

每种 edge 都需要==用户来实现 `computeError` 函数==。由于只链接一个节点，因此 `BaseUnaryEdge` 只多了一个模版参数：节点类型。并且多了一个雅可比矩阵的成员变量：`_jacobianOplusXi`。此外，由于 `HyperGraph::Edge` 类中用了 `vector<Vertex *>` 来存储一条边所连接的节点，因此，`BaseUnaryEdge` 类在初始化的时候会将这个数组 resize 为 1（对应地，`BaseBinaryEdge` 类初始化时会将之 resize 为 2）。

  

其最主要的函数是计算雅可比矩阵的 `linearizeOplus` 函数。可以由用户提供雅可比矩阵的解析解，而默认是 g2o 自己进行数值求导：g2o 使用中值求导方法，其步长 delta 为常数值。函数对节点的 `_estimate` 加上和减去对应步长，再计算对应的误差值，再除以 2*delta 来计算误差函数对于特定误差项的导数。此时，为了保存节点原来的值，就会使用 `push/pop` 函数往 `_backup` 变量中保持修改前的节点估计值。

  

另一个比较主要的函数是 `constructQuadraticForm` 函数。该函数用来计算该误差项的 `系数矩阵H` 和对应的 `b向量`。以 `BaseUnaryEdge` 为例，函数先调用 `chi2函数` 获得误差 $e^T\Omega e$，如果没有使用鲁棒核函数，直接使用  $J^T\Omega J$ 来计算 `系数矩阵H`，用  $J^T\Omega r$ 来计算 `b向量`；否则，调用对应函数得到鲁棒核函数的值，及其一阶导、二阶导（rho，见后面的鲁棒核函数）。b 向量可以直接通过  $-{\rho^\prime}J^T\Omega e$ 来计算，但系数矩阵 H 则调用 `robustInformation函数` 来重新计算加权信息矩阵 `weightedOmega`。

  

`BaseBinaryEdge` 链接两个节点因此比 `BaseEdge` 多两个模版参数。对应的，自然也会有两个雅可比矩阵：`_jacobianOplusXi` 和 `_jacobianOplusXj`。其余本质上和 `BaseUnaryEdge` 并没有差别。需要注意的是，`BaseBinaryEdge` 类也定义了一个 `_hessian` 变量，但这个海塞矩阵并不是残差对于观测（节点）进行求导得到的雅可比 `J` 得到的 $J^TJ$  ，而是通过 $J^T\Omega J$ 得到的，显然，这是 `_Hpl` 矩阵，即位姿和路标点的协方差矩阵（或位姿和位姿间的协方差矩阵）。

  

`BaseMultiEdge` 由于链接的节点数目是不固定的，因此其直接继承 BaseEdge 类而不在需要额外的模版参数。相关的雅可比矩阵也变成了一个 vector 变量：`_jacobianOplus`。链接多个节点并没有带来多大的不同。一些变量如 `_hessian` 和 `_jacobianOplus` 定义成了 vector。而在计算雅可比矩阵（linearizeOplus）时，BaseUnaryEdge 只计算一个雅可比矩阵，BaseBinaryEdge 计算两个，而 BaseMulitEdge 利用循环计算了多个雅可比矩阵，分别存储 `_jacobianOplus[I]` 中；`constructQuadraticForm` 函数也是同理。

  
  
  

![20221010170655](https://raw.githubusercontent.com/seaside2mm/github-photos/master/images/20221010170655.png)

  
  

==计算误差==

`computeActiveErrors()` 函数获取活动顶点的当前估计值，并且对于每个活动边调用 `computeError()` 以计算当前误差向量。使用前面描述的基本边缘类 (个人理解，指的是 BaseUnaryEdge, BaseBinaryEdge 和 BaseMultiEdge)，误差应缓存在成员变量_error 中。

  

如果对于特定活动边 (particular active edge)， `robustKernel()` 设置为 true，则调用 `robustifyError()`，正如前面“稳健最小二乘”的部分中的描述的，`_error` 是健壮的【前面提到了 g2o 是采用 Huber 鲁棒成本函数】。

  

==线性化方程组==

通过调用 `linearizeOplus(`) `函数来线性化每个活动边。 Jacobians也可以通过前面描述的模板化基类提供的成员变量进行缓存。

  

这句话有点含糊，其实应该说的是前面描述的模板化基类中其内部定义有成员变量可以缓存雅克比的计算结果，比如在 `BaseMultiEdge` 的类中，定义了成员变量 `_jacobianOplus`，它的类型是 `std::vector<JacobianType, Eigen::aligned_allocator<JacobianType>>`，在 `BaseBinaryEdge` 中，雅克比相关的成员有 `_jacobianOplusXi` 和 `_jacobianOplusXi`。

  

如果未重新实现 linearizeOplus () 函数，雅可比将按数字计算如下：

![20221010165843](https://raw.githubusercontent.com/seaside2mm/github-photos/master/images/20221010165843.png)

  
  